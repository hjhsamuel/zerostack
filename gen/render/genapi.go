package render

import (
	_ "embed"
	"fmt"
	"go/ast"
	"go/token"
	"os"
	"path/filepath"
	"strings"

	"github.com/hjhsamuel/zerostack/example"
	"github.com/hjhsamuel/zerostack/gen/entities"
	"github.com/hjhsamuel/zerostack/pkg/file"
	"github.com/hjhsamuel/zerostack/pkg/parser/api"
	"github.com/hjhsamuel/zerostack/pkg/parser/gofile"
)

//go:embed api/api.gotmpl
var apiTpl string

//go:embed api/schema.gotmpl
var schemaTpl string

//go:embed api/handler.gotmpl
var handlerTpl string

//go:embed api/handlerApi.gotmpl
var handlerApiTpl string

//go:embed api/group.gotmpl
var groupTpl string

//go:embed api/router.gotmpl
var routerTpl string

const (
	apiFilePath   = "internal/api/api.go"
	baseApiDir    = "api"
	routerDirPath = "internal/api"
)

const (
	handlerImportTpl = `// Code generated by zerostack; Safe to edit.

package handler

import (
	gp "github.com/hjhsamuel/gocommon/gin_plugin"

	"{{.module}}/internal/api/{{.syntax}}/schema"
)`
	handlerDocTpl = `// {{.handler}}
// @Summary {{.summary}}
// @Tags {{.tag}}
// @Accept json
// @Produce json
// @Param req {{if eq .method "GET"}}query{{else}}body{{end}} {{.req}} true "请求参数"
// @Success 200 {object} gp.Response{data={{.rsp}}}
// @Router /{{.service}}/{{.syntax}}/{{.group}}{{.path | ToDocPath}} [{{.method}}]`
	handlerPathTpl = `/{{.service}}/{{.syntax}}/{{.group}}{{.path | ToDocPath}}`
)

func CreateApiFile(base *entities.BaseInfo, path string) error {
	var absPath string
	if filepath.IsAbs(path) {
		absPath = path
	} else {
		absPath = filepath.Join(base.SrvHome, path)
	}

	var (
		baseApiDirPath   = filepath.Join(base.SrvHome, baseApiDir)
		baseRouteDirPath = filepath.Join(base.SrvHome, routerDirPath)
	)
	if !file.Exists(baseApiDirPath) {
		if err := file.MkdirIfNotExist(baseApiDirPath); err != nil {
			return err
		}
		err := file.WriteFile(filepath.Join(baseApiDirPath, "example.api"), example.ApiExampleFile)
		if err != nil {
			return err
		}
	}
	if !file.IsSubPath(absPath, baseApiDirPath) {
		if out, err := file.Copy(absPath, baseApiDirPath); err != nil {
			return err
		} else {
			absPath = out
		}
	}
	return genApi(base, absPath, baseRouteDirPath)
}

func genApi(base *entities.BaseInfo, apiPath, root string) error {
	// 解析api文件并生成渲染参数
	syntaxInfos, err := prepareApis(apiPath, base)
	if err != nil {
		return err
	}
	// 渲染文件
	syntaxs := make([]string, 0)
	for _, syntaxInfo := range syntaxInfos {
		if err = genHandlerApi(root, syntaxInfo.Syntax, base.Module); err != nil {
			return err
		}
		groups := make([]string, 0)
		for _, groupInfo := range syntaxInfo.Groups {
			if err = genGroup(root, groupInfo); err != nil {
				return err
			}
			if err = genSchemas(root, groupInfo); err != nil {
				return err
			}
			if err = genHandlers(root, groupInfo); err != nil {
				return err
			}
			groups = append(groups, groupInfo.GroupName)
		}
		if err = genRouter(root, base, syntaxInfo.Syntax, groups); err != nil {
			return err
		}
		syntaxs = append(syntaxs, syntaxInfo.Syntax)
	}
	if err = genRootApi(root, base, syntaxs); err != nil {
		return err
	}

	return nil
}

func parseApiFile(path string) ([]*entities.ApiFile, error) {
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, err
	}

	res := make([]*entities.ApiFile, 0)
	if info.IsDir() {
		entries, err := os.ReadDir(path)
		if err != nil {
			return nil, err
		}
		for _, entry := range entries {
			out, err := parseApiFile(filepath.Join(path, entry.Name()))
			if err != nil {
				return nil, err
			}
			res = append(res, out...)
		}
	} else {
		if !strings.HasSuffix(path, ".api") {
			return nil, nil
		}
		p, err := api.NewParser(path)
		if err != nil {
			return nil, err
		}
		astDef, err := p.Parse()
		if err != nil {
			return nil, err
		}
		res = append(res, &entities.ApiFile{
			Path: path,
			Api:  astDef,
		})
	}
	return res, nil
}

func prepareApis(path string, base *entities.BaseInfo) ([]*entities.SyntaxInfo, error) {
	// 扫描解析 api 文件
	afs, err := parseApiFile(path)
	if err != nil {
		return nil, err
	}
	// 格式化渲染参数
	afMap := make(map[string]map[string]*api.APIDefinition)
	for _, item := range afs {
		if item.Api == nil || item.Api.Group == nil {
			continue
		}
		var (
			groupName = item.Api.Group.Name
			syntax    = item.Api.Syntax
		)
		if _, ok := afMap[syntax]; !ok {
			afMap[syntax] = make(map[string]*api.APIDefinition)
		}
		if _, ok := afMap[syntax][groupName]; ok {
			return nil, fmt.Errorf("group [%s] repeated in syntax [%s]", groupName, syntax)
		}
		afMap[syntax][groupName] = item.Api
	}

	res := make([]*entities.SyntaxInfo, 0)
	for syntax, v := range afMap {
		groups := make([]*entities.RouteInfo, 0)
		for groupName, vv := range v {
			var (
				types      = make([]*entities.GenType, 0)
				handlerMap = make(map[string]*entities.GenHandler)
			)
			for _, t := range vv.Types {
				fields := make([]*entities.GenField, 0)
				for _, field := range t.Fields {
					tags := make([]*entities.GenTag, 0)
					for _, tag := range field.Tags {
						tags = append(tags, &entities.GenTag{Key: tag.Key, Val: tag.Val})
					}
					fields = append(fields, &entities.GenField{
						Name:    field.Name,
						Type:    field.Type,
						Tags:    tags,
						Comment: field.Comment,
					})
				}
				types = append(types, &entities.GenType{Name: t.Name, Fields: fields})
			}
			for _, h := range vv.Group.Handlers {
				if _, ok := handlerMap[h.FuncName]; ok {
					return nil, fmt.Errorf("handler [%s] repeated in group [%s.%s]", h.FuncName, syntax, groupName)
				}
				handlerMap[h.FuncName] = &entities.GenHandler{
					Method: h.Method,
					Path:   h.Path,
					Req:    h.ReqType,
					Rsp: &entities.GenRsp{
						Base: h.RspType.Base,
						Type: h.RspType.Type,
					},
					Handler: h.FuncName,
					Doc:     &entities.GenDoc{Summary: h.Doc.Summary},
				}
			}
			groups = append(groups, &entities.RouteInfo{
				GroupName: groupName,
				Params: &entities.GenInfo{
					Module:  base.Module,
					Service: base.Service,
					Syntax:  syntax,
					Types:   types,
					Group: &entities.GenGroup{
						Name: groupName,
						Route: &entities.GenRoute{
							Tag:  vv.Group.RouteMeta.Tag,
							Auth: vv.Group.RouteMeta.Auth,
						},
						Handler: handlerMap,
					},
				},
			})
		}
		res = append(res, &entities.SyntaxInfo{
			Syntax: syntax,
			Groups: groups,
		})
	}
	return res, nil
}

// 不关心 schema 文件是否存在，直接覆盖重写
func genSchemas(root string, info *entities.RouteInfo) error {
	schemaPath := filepath.Join(root, info.Params.Syntax, "schema", info.GroupName+".go")
	return OverwriteGoTemplate(schemaTpl, schemaPath, info.Params)
}

// 倾向于新增操作
// 当方法名称相同时，做更新操作
func genHandlers(root string, info *entities.RouteInfo) error {
	if info.Params.Group == nil || info.Params.Group.Handler == nil || len(info.Params.Group.Handler) == 0 {
		return nil
	}
	handlerMap := info.Params.Group.Handler

	handlerPath := filepath.Join(root, info.Params.Syntax, info.GroupName+".go")
	if file.Exists(handlerPath) {
		copiedHandler := make(map[string]*entities.GenHandler)
		for k, v := range handlerMap {
			copiedHandler[k] = v
		}

		fset, f, err := gofile.ParseGoFile(handlerPath)
		if err != nil {
			return err
		}
		var (
			rewrite   = false
			additions string
		)
		for _, decl := range f.Decls {
			// 判断是否为 handler 方法
			funcDecl, ok := decl.(*ast.FuncDecl)
			if !ok || funcDecl.Recv.NumFields() != 1 {
				continue
			}
			starDecl, ok := funcDecl.Recv.List[0].Type.(*ast.StarExpr)
			if !ok {
				continue
			}
			ident, ok := starDecl.X.(*ast.Ident)
			if !ok || ident.Name != "Api" {
				continue
			}
			if _, ok = copiedHandler[funcDecl.Name.Name]; !ok {
				continue
			}
			// 检查 handler 是否一致
			if diff, err := diffFunc(funcDecl, copiedHandler[funcDecl.Name.Name]); err != nil {
				return err
			} else if diff {
				rewrite = true
			}
			// 检查 doc 是否一致
			if diff, err := diffDoc(funcDecl, info); err != nil {
				return err
			} else if diff {
				rewrite = true
			}
			// 移除 handler
			delete(copiedHandler, funcDecl.Name.Name)
		}
		if len(copiedHandler) != 0 {
			additions, err = GetRenderedContent(info.GroupName, handlerTpl, &entities.GenInfo{
				Module:  info.Params.Module,
				Service: info.Params.Service,
				Syntax:  info.Params.Syntax,
				Types:   info.Params.Types,
				Group: &entities.GenGroup{
					Name:    info.Params.Group.Name,
					Route:   info.Params.Group.Route,
					Handler: copiedHandler,
				},
			})
			if err != nil {
				return err
			}
			rewrite = true
		}
		if rewrite {
			content, err := gofile.AstToGoCode(fset, f)
			if err != nil {
				return err
			}
			if additions != "" {
				content += additions
			}
			if err = os.WriteFile(handlerPath, []byte(content), os.ModePerm); err != nil {
				return err
			}
		}
	} else {
		importContent, err := GetRenderedContent(info.GroupName+".import", handlerImportTpl, info.Params)
		if err != nil {
			return err
		}
		handlerContent, err := GetRenderedContent(info.GroupName, handlerTpl, info.Params)
		if err != nil {
			return err
		}
		if err = os.WriteFile(handlerPath, []byte(importContent+handlerContent), os.ModePerm); err != nil {
			return err
		}
	}
	return nil
}

func diffFunc(fd *ast.FuncDecl, handler *entities.GenHandler) (bool, error) {
	var (
		rspName   string
		rspIsBase bool
	)
	if handler.Rsp == nil || !handler.Rsp.Base {
		rspName = "*schema." + handler.Rsp.Type
	} else {
		rspName = handler.Rsp.Type
		rspIsBase = true
	}

	var diff bool

	// 判断 handler 参数是否发生变更
	expectFuncSignature := gofile.FuncSignature{
		Recv:    "*Api",
		Name:    handler.Handler,
		Params:  []string{"*gp.Context", "*schema." + handler.Req},
		Results: []string{rspName, "error"},
	}
	sig := gofile.BuildFunSignature(fd)
	if !gofile.IsSameFuncSignature(sig, expectFuncSignature) {
		// 重写入参和出参
		fd.Type.Params = &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{{Name: "ctx"}},
					Type: &ast.StarExpr{
						X: &ast.SelectorExpr{
							X:   &ast.Ident{Name: "gp"},
							Sel: &ast.Ident{Name: "Context"},
						},
					},
				},
				{
					Names: []*ast.Ident{{Name: "req"}},
					Type: &ast.StarExpr{
						X: &ast.SelectorExpr{
							X:   &ast.Ident{Name: "schema"},
							Sel: &ast.Ident{Name: handler.Req},
						},
					},
				},
			},
		}
		fd.Type.Results = &ast.FieldList{List: make([]*ast.Field, 2)}
		if rspIsBase {
			fd.Type.Results.List[0] = &ast.Field{Type: &ast.Ident{Name: rspName}}
		} else {
			fd.Type.Results.List[0] = &ast.Field{
				Type: &ast.StarExpr{
					X: &ast.SelectorExpr{
						X:   &ast.Ident{Name: "schema"},
						Sel: &ast.Ident{Name: handler.Rsp.Type},
					},
				},
			}
		}
		fd.Type.Results.List[1] = &ast.Field{Type: &ast.Ident{Name: "error"}}
		diff = true
	}

	return diff, nil
}

func diffDoc(fd *ast.FuncDecl, info *entities.RouteInfo) (bool, error) {
	handler := info.Params.Group.Handler[fd.Name.Name]

	var diff bool

	path, err := GetRenderedContentByParams(
		fd.Name.Name+".path",
		handlerPathTpl,
		map[string]any{
			"service": info.Params.Service,
			"syntax":  info.Params.Syntax,
			"group":   info.GroupName,
			"path":    handler.Path,
		},
	)
	if err != nil {
		return false, err
	}

	expectDocSignature := gofile.SwaggerSignature{
		FuncName: handler.Handler,
		Req:      handler.Req,
		Path:     path,
		Method:   handler.Method,
	}
	if handler.Doc != nil {
		expectDocSignature.Summary = handler.Doc.Summary
	}
	if info.Params.Group.Route != nil {
		expectDocSignature.Tag = info.Params.Group.Route.Tag
	}
	if handler.Rsp.Base {
		expectDocSignature.Rsp = handler.Rsp.Type
	} else {
		expectDocSignature.Rsp = "*schema." + handler.Rsp.Type
	}

	sig := gofile.BuildSwaggerSignature(fd)
	if !gofile.IsSameSwaggerSignature(sig, expectDocSignature) {
		content, err := GetRenderedContentByParams(
			fd.Name.Name+".doc",
			handlerDocTpl,
			map[string]any{
				"handler": handler.Handler,
				"summary": expectDocSignature.Summary,
				"tag":     expectDocSignature.Tag,
				"method":  expectDocSignature.Method,
				"req":     expectDocSignature.Req,
				"rsp":     expectDocSignature.Rsp,
				"service": info.Params.Service,
				"syntax":  info.Params.Syntax,
				"group":   info.GroupName,
				"path":    expectDocSignature.Path,
			},
		)
		if err != nil {
			return false, err
		}
		lines := strings.FieldsFunc(content, func(r rune) bool {
			return r == '\n'
		})
		docs := make([]*ast.Comment, len(lines))
		for index, line := range lines {
			docs[index] = &ast.Comment{Text: line}
		}
		fd.Doc = &ast.CommentGroup{List: docs}

		diff = true
	}

	return diff, nil
}

func genHandlerApi(root, syntax, module string) error {
	path := filepath.Join(root, syntax, "handler", "api.go")
	if !file.Exists(path) {
		return CreateGoTemplate(handlerApiTpl, path, &entities.GenInfo{
			Module: module,
			Syntax: syntax,
		})
	}
	return nil
}

func genGroup(root string, info *entities.RouteInfo) error {
	path := filepath.Join(root, info.Params.Syntax, info.GroupName+".go")
	if file.Exists(path) {
		return OverwriteGoTemplate(groupTpl, path, info.Params)
	} else {
		return CreateGoTemplate(groupTpl, path, info.Params)
	}
}

func genRouter(root string, base *entities.BaseInfo, syntax string, groups []string) error {
	path := filepath.Join(root, syntax, "router.go")
	if file.Exists(path) {
		groupMap := make(map[string]struct{})
		for _, group := range groups {
			groupMap[group] = struct{}{}
		}

		fset, f, err := gofile.ParseGoFile(path)
		if err != nil {
			return err
		}
		for _, decl := range f.Decls {
			funcDecl, ok := decl.(*ast.FuncDecl)
			if !ok || funcDecl.Name.Name != "Route" {
				continue
			}
			for _, stmt := range funcDecl.Body.List {
				exprStmt, ok := stmt.(*ast.ExprStmt)
				if !ok {
					continue
				}
				callExpr, ok := exprStmt.X.(*ast.CallExpr)
				if !ok {
					continue
				}
				ident, ok := callExpr.Fun.(*ast.Ident)
				if !ok {
					continue
				}
				if _, ok = groupMap[ident.Name]; ok {
					delete(groupMap, ident.Name)
					continue
				}
			}
			if len(groupMap) != 0 {
				for group := range groupMap {
					funcDecl.Body.List = append(funcDecl.Body.List, &ast.ExprStmt{
						X: &ast.CallExpr{
							Fun: &ast.Ident{Name: group},
							Args: []ast.Expr{
								&ast.Ident{Name: "api"},
								&ast.Ident{Name: "group"},
							},
						},
					})
				}
			}
			break
		}
		if len(groupMap) != 0 {
			content, err := gofile.AstToGoCode(fset, f)
			if err != nil {
				return err
			}
			return os.WriteFile(path, []byte(content), os.ModePerm)
		}
		return nil
	} else {
		content, err := GetRenderedContentByParams("router", routerTpl, map[string]any{
			"syntax": syntax,
			"module": base.Module,
			"groups": groups,
		})
		if err != nil {
			return err
		}
		f, err := os.Create(path)
		if err != nil {
			return err
		}
		defer f.Close()
		_, err = f.WriteString(content)
		return err
	}
}

func genRootApi(root string, base *entities.BaseInfo, syntaxs []string) error {
	path := filepath.Join(root, "router.go")
	if file.Exists(path) {
		syntaxMap := make(map[string]struct{})
		for _, syntax := range syntaxs {
			syntaxMap[syntax] = struct{}{}
		}

		fset, f, err := gofile.ParseGoFile(path)
		if err != nil {
			return err
		}
		var (
			importDecl *ast.GenDecl
			routeDecl  *ast.FuncDecl
		)
		for _, decl := range f.Decls {
			switch decl.(type) {
			case *ast.GenDecl:
				genDecl := decl.(*ast.GenDecl)
				if genDecl.Tok != token.IMPORT {
					continue
				}
				importDecl = genDecl
				for _, spec := range genDecl.Specs {
					importSpec, ok := spec.(*ast.ImportSpec)
					if !ok {
						continue
					}
					if importSpec.Name == nil {
						continue
					}
					if _, ok = syntaxMap[importSpec.Name.Name]; ok {
						delete(syntaxMap, importSpec.Name.Name)
					}
				}
			case *ast.FuncDecl:
				funcDecl := decl.(*ast.FuncDecl)
				if funcDecl.Name.Name != "Route" {
					continue
				}
				routeDecl = funcDecl
			default:
				continue
			}
		}
		if len(syntaxMap) != 0 {
			for syntax := range syntaxMap {
				importDecl.Specs = append(importDecl.Specs, &ast.ImportSpec{
					Name: &ast.Ident{Name: syntax},
					Path: &ast.BasicLit{
						Kind:  token.STRING,
						Value: fmt.Sprintf(`"%s/internal/api/%s"`, base.Module, syntax),
					},
				})
				routeDecl.Body.List = append(routeDecl.Body.List, &ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   &ast.Ident{Name: syntax},
							Sel: &ast.Ident{Name: "Route"},
						},
						Args: []ast.Expr{
							&ast.Ident{Name: "srv"},
							&ast.Ident{Name: "group"},
						},
					},
				})
			}
			content, err := gofile.AstToGoCode(fset, f)
			if err != nil {
				return err
			}
			return os.WriteFile(path, []byte(content), os.ModePerm)
		}
		return nil
	} else {
		content, err := GetRenderedContentByParams("api", apiTpl, map[string]any{
			"module":  base.Module,
			"service": base.Service,
			"syntaxs": syntaxs,
		})
		if err != nil {
			return err
		}
		f, err := os.Create(path)
		if err != nil {
			return err
		}
		defer f.Close()
		_, err = f.WriteString(content)
		return err
	}
}
