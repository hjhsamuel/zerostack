package render

import (
	_ "embed"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/hjhsamuel/zerostack/example"
	"github.com/hjhsamuel/zerostack/gen/entities"
	"github.com/hjhsamuel/zerostack/pkg/file"
	"github.com/hjhsamuel/zerostack/pkg/parser/api"
)

//go:embed api/api.gotmpl
var apiTpl string

//go:embed api/schema.gotmpl
var schemaTpl string

const (
	apiFilePath   = "internal/api/api.go"
	baseApiDir    = "api"
	routerDirPath = "internal/api"
)

const (
	handlerPackageTpl = `// Code generated by zerostack; Safe to edit.

package {{.syntax}}

import (
	gp "github.com/hjhsamuel/gocommon/gin_plugin"

	"{{.module}}/internal/api/{{.syntax}}/schema"
)`
	handlerFuncTpl = `func (api *Api) {{.handler}}(ctx *gp.Context, req *schema.{{.req}}) ({{.rsp}}, error)`
)

func CreateApiFile(base *entities.BaseInfo, path string) error {
	var absPath string
	if filepath.IsAbs(path) {
		absPath = path
	} else {
		absPath = filepath.Join(base.SrvHome, path)
	}

	var (
		baseApiDirPath   = filepath.Join(base.SrvHome, baseApiDir)
		baseRouteDirPath = filepath.Join(base.SrvHome, routerDirPath)
	)
	if !file.Exists(baseApiDirPath) {
		if err := file.MkdirIfNotExist(baseApiDirPath); err != nil {
			return err
		}
		err := file.WriteFile(filepath.Join(baseApiDirPath, "example.api"), example.ApiExampleFile)
		if err != nil {
			return err
		}
	}
	if !file.IsSubPath(absPath, baseApiDirPath) {
		if out, err := file.Copy(absPath, baseApiDirPath); err != nil {
			return err
		} else {
			absPath = out
		}
	}
	return genApi(base, absPath, baseRouteDirPath)
}

func genApi(base *entities.BaseInfo, apiPath, root string) error {
	// 解析api文件并生成渲染参数
	routeInfos, err := prepareApis(apiPath, base)
	if err != nil {
		return err
	}
	// 渲染文件
	for _, item := range routeInfos {
		if err = genSchemas(root, item); err != nil {
			return err
		}
		// TODO
	}
}

func parseApiFile(path string) ([]*entities.ApiFile, error) {
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, err
	}

	res := make([]*entities.ApiFile, 0)
	if info.IsDir() {
		entries, err := os.ReadDir(path)
		if err != nil {
			return nil, err
		}
		for _, entry := range entries {
			out, err := parseApiFile(filepath.Join(path, entry.Name()))
			if err != nil {
				return nil, err
			}
			res = append(res, out...)
		}
	} else {
		if !strings.HasSuffix(path, ".api") {
			return nil, nil
		}
		p, err := api.NewParser(path)
		if err != nil {
			return nil, err
		}
		astDef, err := p.Parse()
		if err != nil {
			return nil, err
		}
		res = append(res, &entities.ApiFile{
			Path: path,
			Api:  astDef,
		})
	}
	return res, nil
}

func prepareApis(path string, base *entities.BaseInfo) ([]*entities.RouteInfo, error) {
	// 扫描解析 api 文件
	afs, err := parseApiFile(path)
	if err != nil {
		return nil, err
	}
	// 格式化渲染参数
	afMap := make(map[string]map[string]*api.APIDefinition)
	for _, item := range afs {
		if _, ok := afMap[item.Api.Syntax]; !ok {
			afMap[item.Api.Syntax] = make(map[string]*api.APIDefinition)
		}
		fileName := filepath.Base(item.Path)
		basename := strings.TrimSuffix(fileName, filepath.Ext(fileName))
		if _, ok := afMap[item.Api.Syntax][basename]; ok {
			return nil, fmt.Errorf("file [%s] repeated in syntax [%s]", fileName, item.Api.Syntax)
		}
		afMap[item.Api.Syntax][basename] = item.Api
	}

	res := make([]*entities.RouteInfo, 0)
	for syntax, v := range afMap {
		for name, vv := range v {
			var (
				types  = make([]map[string]any, 0)
				groups = make([]map[string]any, 0)
			)
			for _, t := range vv.Types {
				fields := make([]map[string]any, 0)
				for _, field := range t.Fields {
					tags := make([]map[string]string, 0)
					for _, tag := range field.Tags {
						tags = append(tags, map[string]string{"key": tag.Key, "val": tag.Val})
					}
					fields = append(fields, map[string]any{
						"name":    field.Name,
						"type":    field.Type,
						"tags":    tags,
						"comment": field.Comment,
					})
				}
				types = append(types, map[string]any{"name": t.Name, "fields": fields})
			}
			for _, g := range vv.Groups {
				handlers := make([]map[string]any, 0)
				for _, h := range g.Handlers {
					handlers = append(handlers, map[string]any{
						"method":  h.Method,
						"path":    h.Path,
						"req":     h.ReqType,
						"rsp":     h.RspType,
						"handler": h.FuncName,
						"doc": map[string]string{
							"summary": h.Doc.Summary,
						},
					})
				}
				groups = append(groups, map[string]any{
					"name": g.Name,
					"route": map[string]any{
						"tag":  g.RouteMeta.Tag,
						"auth": g.RouteMeta.Auth,
					},
					"handlers": handlers,
				})
			}
			res = append(res, &entities.RouteInfo{
				Syntax:   syntax,
				FileName: name,
				Params: map[string]any{
					"module":  base.Module,
					"service": base.Service,
					"syntax":  syntax,
					"types":   types,
					"groups":  groups,
				},
			})
		}
	}
	return res, nil
}

// 不关心 schema 文件是否存在，直接覆盖重写
func genSchemas(root string, info *entities.RouteInfo) error {
	schemaPath := filepath.Join(root, info.Syntax, "schema", info.FileName+".go")
	return OverwriteGoTemplate(schemaTpl, schemaPath, info.Params)
}
